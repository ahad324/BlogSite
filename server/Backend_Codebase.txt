/Users/macbook/Documents/BlogSite/server/Backend_Structure.txt
<DOCUMENT>
Directory Structure:

├── .env
├── .gitignore
├── .prettierrc
├── README.md
├── Structuremaker.py
├── eslint.config.js
├── package.json
├── src/
│   ├── config/
│   │   ├── db.js
│   ├── controllers/
│   │   ├── comment.controller.js
│   │   ├── post.controller.js
│   │   ├── user.controller.js
│   ├── docs/
│   │   ├── data-flow.dot
│   │   ├── data-flow.md
│   │   ├── database-design.md
│   │   ├── erd.dot
│   │   ├── indexing-strategy.dot
│   │   ├── query-performance.md
│   ├── index.js
│   ├── middlewares/
│   │   ├── auth.middleware.js
│   │   ├── error.middleware.js
│   │   ├── validate.middleware.js
│   ├── models/
│   │   ├── comment.model.js
│   │   ├── post.model.js
│   │   ├── user.model.js
│   ├── routes/
│   │   ├── comment.routes.js
│   │   ├── index.js
│   │   ├── post.routes.js
│   │   ├── user.routes.js
│   ├── utils/
│   │   ├── helpers.js
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/README.md
<DOCUMENT>
# BlogSite Backend

A professional MERN stack backend for a blog system with users, posts, and comments, implementing Task 3 requirements.

## Features

- MongoDB schema design with one-to-many and many-to-many relationships
- Pagination, filtering, and sorting for posts and comments
- Optimized queries with indexing
- Input validation using Joi
- Error handling and logging
- ES modules and modern JavaScript practices

## Setup

1. Clone the repository: `git clone <repo-url>`
2. Navigate to the server directory: `cd BlogSite/server`
3. Install dependencies: `npm install`
4. Create a `.env` file with `MONGO_URI` and `PORT`
5. Run in development mode: `npm run dev`

## Scripts

- `npm start`: Run the server in production
- `npm run dev`: Run the server with nodemon
- `npm run lint`: Run ESLint
- `npm run format`: Run Prettier
- `npm run lint:check`: Check ESLint with no warnings
- `npm run format:check`: Check Prettier formatting

## Project Structure

```
server/
├── src/
│   ├── config/
│   │   └── db.js
│   ├── controllers/
│   │   ├── user.controller.js
│   │   ├── post.controller.js
│   │   └── comment.controller.js
│   ├── models/
│   │   ├── user.model.js
│   │   ├── post.model.js
│   │   └── comment.model.js
│   ├── routes/
│   │   ├── user.routes.js
│   │   ├── post.routes.js
│   │   ├── comment.routes.js
│   │   └── index.js
│   ├── middlewares/
│   │   ├── error.middleware.js
│   │   └── validate.middleware.js
│   ├── utils/
│   │   └── helpers.js
│   └── index.js
├── .env
├── .gitignore
├── package.json
├── .prettierrc
├── eslint.config.js
└── README.md
```

## API Endpoints

- **POST /api/users** : Create a new user
- **GET /api/users/:id** : Get user details with posts
- **POST /api/posts** : Create a new post
- **GET /api/posts** : Get paginated posts with filtering and sorting
- **GET /api/posts/:id** : Get a single post with comments
- **PUT /api/posts/:id** : Update a post
- **DELETE /api/posts/:id** : Delete a post and its comments
- **POST /api/comments** : Create a new comment
- **GET /api/comments/post/:postId** : Get paginated comments for a post
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/.gitignore
<DOCUMENT>
node_modules
.env
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/package.json
<DOCUMENT>
{
  "name": "server",
  "version": "1.0.0",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "lint": "eslint .",
    "format": "prettier --write .",
    "lint:check": "eslint . --max-warnings=0",
    "format:check": "prettier --check ."
  },
  "keywords": [
    "mern",
    "blog",
    "api"
  ],
  "author": "AbdulAhad",
  "license": "ISC",
  "description": "Blog system backend API",
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^17.1.0",
    "express": "^5.1.0",
    "helmet": "^8.1.0",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.16.2",
    "mongoose-paginate-v2": "^1.8.5",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.30.1",
    "eslint": "^9.30.1",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-node": "^11.1.0",
    "globals": "^16.3.0",
    "nodemon": "^3.1.10",
    "prettier": "^3.6.2"
  }
}
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/.env
<DOCUMENT>
MONGO_URI=mongodb://localhost:27017/BlogSite
PORT=3000
JWT_SECRET=your-secure-jwt-secret
CLIENT_URL=http://localhost:5173
NODE_ENV=development
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/.prettierrc
<DOCUMENT>
{
  "singleQuote": true,
  "trailingComma": "es5",
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true
}
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/Structuremaker.py
<DOCUMENT>
import os

EXTENSION = ".txt"
EXCLUDED_DIRS = {"node_modules"}
EXCLUDED_FILES = {"package-lock.json"}
EXCLUDED_EXTENSIONS = {".png", ".jpg", ".jpeg", ".svg", ".gif", ".webp", ".ico"}


def should_exclude(file):
    _, ext = os.path.splitext(file)
    return file in EXCLUDED_FILES or ext.lower() in EXCLUDED_EXTENSIONS


def generate_structure(path, depth=0):
    structure = ""
    try:
        for item in sorted(os.listdir(path)):
            if item in EXCLUDED_DIRS:
                continue
            item_path = os.path.join(path, item)
            if os.path.isdir(item_path):
                structure += "│   " * depth + "├── " + item + "/\n"
                structure += generate_structure(item_path, depth + 1)
            elif not should_exclude(item):
                structure += "│   " * depth + "├── " + item + "\n"
    except PermissionError:
        structure += "│   " * depth + "├── [Permission Denied]\n"
    return structure


def show_file_contents(path, output_file):
    if should_exclude(os.path.basename(path)):
        return
    try:
        with open(path, "r", encoding="utf-8") as f:
            content = f.read().strip()
        if not content:
            return
        foldername, filename = os.path.split(path)
        foldername = foldername.replace(os.path.sep, "/")
        output_file.write(f"{foldername}/{filename}\n")
        output_file.write("<DOCUMENT>\n")
        output_file.write(content + "\n")
        output_file.write("</DOCUMENT>\n\n")
    except Exception as e:
        print(f"Error reading file {path}: {e}")


def process_server_folder():
    base_path = os.getcwd()
    label = "Backend"

    # Structure
    structure = generate_structure(base_path)
    structure_filename = f"{label}_Structure{EXTENSION}"
    with open(structure_filename, "w", encoding="utf-8") as f:
        f.write("Directory Structure:\n\n")
        f.write(structure)
    print(f"{label} structure saved to {structure_filename}")

    # Codebase
    content_filename = f"{label}_Codebase{EXTENSION}"
    with open(content_filename, "w", encoding="utf-8") as output_file:
        for root, dirs, files in os.walk(base_path):
            dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]
            for file in files:
                if should_exclude(file):
                    continue
                file_path = os.path.join(root, file)
                show_file_contents(file_path, output_file)
    print(f"{label} codebase saved to {content_filename}")


if __name__ == "__main__":
    process_server_folder()
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/eslint.config.js
<DOCUMENT>
import eslintPluginNode from 'eslint-plugin-node';
import eslintRecommended from '@eslint/js';
import prettier from 'eslint-config-prettier';
import globals from 'globals';

export default [
  {
    files: ['**/*.js'],
    ignores: ['node_modules/', 'dist/'],
    languageOptions: {
      ecmaVersion: 2021,
      sourceType: 'module',
      globals: {
        ...globals.node,
        ...globals.es2021,
      },
    },
    plugins: {
      node: eslintPluginNode,
    },
    rules: {
      ...eslintRecommended.configs.recommended.rules,
      ...prettier.rules,
      indent: ['error', 2],
      quotes: ['error', 'single'],
      semi: ['error', 'always'],
      'no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
      'node/no-unsupported-features/es-syntax': 'off',
    },
  },
];
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/index.js
<DOCUMENT>
import express from 'express';
import cors from 'cors';
import morgan from 'morgan';
import dotenv from 'dotenv';
import helmet from 'helmet';
import cookieParser from 'cookie-parser';
import connectDB from './config/db.js';
import router from './routes/index.js';
import errorMiddleware from './middlewares/error.middleware.js';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(
  cors({
    origin: process.env.CLIENT_URL || 'http://localhost:5173',
    credentials: true,
  })
);
app.use(morgan('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

// Routes
app.use('/api', router);

// Error Handling
app.use(errorMiddleware);

// Start server after DB connection
async function startServer() {
  try {
    await connectDB();
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Server startup error:', error);
    process.exit(1);
  }
}

startServer();
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/config/db.js
<DOCUMENT>
import mongoose from 'mongoose';

async function connectDB() {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      dbName: 'BlogSite',
    });
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
}

export default connectDB;
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/middlewares/error.middleware.js
<DOCUMENT>
export default function errorMiddleware(err, req, res, _next) {
  console.error(err.stack);
  const status = err.status || 500;
  const message = err.message || 'Internal Server Error';
  res.status(status).json({ error: message });
}
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/middlewares/validate.middleware.js
<DOCUMENT>
export function validate(schema) {
  return async (req, res, next) => {
    try {
      await schema.validateAsync(req.body, { abortEarly: false });
      next();
    } catch (error) {
      next({ status: 400, message: error.message });
    }
  };
}
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/middlewares/auth.middleware.js
<DOCUMENT>
import jwt from 'jsonwebtoken';
import { asyncHandler } from '../utils/helpers.js';

export const authMiddleware = asyncHandler(async (req, res, next) => {
  const token = req.cookies.token;
  if (!token) {
    return res.status(401).json({ message: 'Authentication token missing' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = { id: decoded.id };
    next();
  } catch (error) {
    res.status(401).json({ message: `Invalid or expired token ${error}` });
  }
});
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/utils/helpers.js
<DOCUMENT>
import Joi from 'joi';
import mongoose from 'mongoose';

export function asyncHandler(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

export const registerUserSchema = Joi.object({
  username: Joi.string().min(3).required(),
  email: Joi.string().email().required(),
  password: Joi.string().min(6).required(),
});

export const loginUserSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().required(),
});

export const createPostSchema = Joi.object({
  title: Joi.string().min(5).required(),
  content: Joi.string().required(),
  tags: Joi.array().items(Joi.string()).optional(),
});

export const updatePostSchema = Joi.object({
  title: Joi.string().min(5).optional(),
  content: Joi.string().optional(),
  tags: Joi.array().items(Joi.string()).optional(),
});

export const createCommentSchema = Joi.object({
  content: Joi.string().min(2).required(),
  post: Joi.string()
    .custom((value, helpers) => {
      if (!mongoose.isValidObjectId(value)) {
        return helpers.error('any.invalid');
      }
      return value;
    })
    .required(),
});

export const updateCommentSchema = Joi.object({
  content: Joi.string().min(2).optional(),
});
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/models/post.model.js
<DOCUMENT>
import mongoose from 'mongoose';
import mongoosePaginate from 'mongoose-paginate-v2';

const postSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: [true, 'Title is required'],
      trim: true,
      minlength: [5, 'Title must be at least 5 characters'],
    },
    content: {
      type: String,
      required: [true, 'Content is required'],
      trim: true,
    },
    author: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Author is required'],
    },
    tags: [
      {
        type: String,
        trim: true,
      },
    ],
    comments: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Comment',
      },
    ],
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes for efficient querying
postSchema.index({ author: 1 });
postSchema.index({ createdAt: -1 });
postSchema.index({ tags: 1 });

// Add pagination plugin
postSchema.plugin(mongoosePaginate);

const Post = mongoose.model('Post', postSchema);

export default Post;
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/models/comment.model.js
<DOCUMENT>
import mongoose from 'mongoose';
import mongoosePaginate from 'mongoose-paginate-v2';

const commentSchema = new mongoose.Schema(
  {
    content: {
      type: String,
      required: [true, 'Content is required'],
      trim: true,
      minlength: [2, 'Comment must be at least 2 characters'],
    },
    author: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Author is required'],
    },
    post: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Post',
      required: [true, 'Post is required'],
    },
  },
  {
    timestamps: true,
  }
);

// Indexes for efficient querying
commentSchema.index({ post: 1, createdAt: -1 });
commentSchema.index({ author: 1 });

// Add pagination plugin
commentSchema.plugin(mongoosePaginate);

const Comment = mongoose.model('Comment', commentSchema);

export default Comment;
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/models/user.model.js
<DOCUMENT>
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const userSchema = new mongoose.Schema(
  {
    username: {
      type: String,
      required: [true, 'Username is required'],
      unique: true,
      trim: true,
      minlength: [3, 'Username must be at least 3 characters'],
    },
    email: {
      type: String,
      required: [true, 'Email is required'],
      unique: true,
      trim: true,
      lowercase: true,
      match: [/.+@.+\..+/, 'Please enter a valid email address'],
    },
    password: {
      type: String,
      required: [true, 'Password is required'],
      minlength: [6, 'Password must be at least 6 characters'],
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Virtual for posts authored by user
userSchema.virtual('posts', {
  ref: 'Post',
  localField: '_id',
  foreignField: 'author',
});

// Hash password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

// Compare password for login
userSchema.methods.comparePassword = async function (candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

const User = mongoose.model('User', userSchema);

export default User;
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/docs/indexing-strategy.dot
<DOCUMENT>
digraph BlogSite_Indexing_Strategy {
  rankdir=TB;
  graph [bgcolor="#F5F7FA", splines=spline, pad=0.5, nodesep=0.6, ranksep=1.0];
  node [shape=box, style="filled,rounded", fillcolor="#90EE90", color="#228B22", penwidth=2, fontname="Arial", fontsize=12, margin=0.2];
  edge [color="#2F4F4F", fontname="Arial", fontsize=11, arrowsize=0.8, penwidth=1.5, splines=spline];

  // Title
  labelloc="t";
  label="BlogSite Indexing Strategy";
  fontsize=16;
  fontname="Arial";
  fontcolor="#2F4F4F";

  // Entities and Indexes
  User [label="User\nusername: unique\n  - User Lookup (High)\n  - Ex: User.findOne({ username: 'user' })\nemail: unique\n  - User Lookup (High)\n  - Ex: User.findOne({ email: 'user@example.com' })", fillcolor="#98FB98"];
  Post [label="Post\nauthor: index\n  - Author Queries (Medium)\n  - Ex: Post.find({ author: <id> })\ncreatedAt: index\n  - Sorting (High)\n  - Ex: Post.find().sort({ createdAt: -1 })\ntags: index\n  - Tag Filtering (Medium)\n  - Ex: Post.find({ tags: 'tech' })\ntitle: text\n  - Keyword Search (Medium)\n  - Ex: Post.find({ $text: { $search: 'title' } })\ncontent: text\n  - Keyword Search (Medium)\n  - Ex: Post.find({ $text: { $search: 'content' } })\ntags,author: compound\n  - Combined Filter (Medium)\n  - Ex: Post.find({ tags: 'tech', author: <id> })", fillcolor="#90EE90"];
  Comment [label="Comment\npost: index\n  - Post Comments (High)\n  - Ex: Comment.find({ post: <id> })\ncreatedAt: index\n  - Sorting (Medium)\n  - Ex: Comment.find().sort({ createdAt: -1 })\nauthor: index\n  - Author Queries (Low)\n  - Ex: Comment.find({ author: <id> })", fillcolor="#98FB98"];

  // Query Purposes
  User_Lookup [shape=plaintext, fontname="Arial", fontsize=11, label="User Lookup"];
  Author_Queries [shape=plaintext, fontname="Arial", fontsize=11, label="Author Queries"];
  Sorting [shape=plaintext, fontname="Arial", fontsize=11, label="Sorting"];
  Tag_Filtering [shape=plaintext, fontname="Arial", fontsize=11, label="Tag Filtering"];
  Keyword_Search [shape=plaintext, fontname="Arial", fontsize=11, label="Keyword Search"];
  Combined_Filter [shape=plaintext, fontname="Arial", fontsize=11, label="Combined Tag-Author Filter"];
  Post_Comments [shape=plaintext, fontname="Arial", fontsize=11, label="Post Comments"];

  // Relationships
  User -> User_Lookup [label="username, email", style=solid, color="#4682B4", penwidth=2.5, arrowhead=vee];
  Post -> Author_Queries [label="author", style=solid, color="#2F4F4F", arrowhead=vee];
  Post -> Sorting [label="createdAt", style=solid, color="#4682B4", penwidth=2.5, arrowhead=vee];
  Post -> Tag_Filtering [label="tags", style=solid, color="#2F4F4F", arrowhead=vee];
  Post -> Keyword_Search [label="title, content", style=solid, color="#2F4F4F", arrowhead=vee];
  Post -> Combined_Filter [label="tags,author", style=solid, color="#2F4F4F", arrowhead=vee];
  Comment -> Post_Comments [label="post", style=solid, color="#4682B4", penwidth=2.5, arrowhead=vee];
  Comment -> Sorting [label="createdAt", style=solid, color="#2F4F4F", arrowhead=vee];
  Comment -> Author_Queries [label="author", style=solid, color="#2F4F4F", arrowhead=vee];

  // Legend
  subgraph cluster_legend {
    label="Legend";
    fontsize=12;
    fontname="Arial";
    style="dashed,rounded";
    color="#708090";
    fillcolor="#F0F8FF";
    Legend [shape=plaintext, label="Solid Line: Index to Query Purpose\nBlue/Thick Line: High Priority Queries\nUnique: Ensures uniqueness\nText: Enables keyword search\nCompound: Optimizes multi-field queries"];
  }

  // Footer Note
  subgraph cluster_footer {
    style=invis;
    Footer [shape=plaintext, label="Generated for BlogSite Backend, Task 3, July 2025", fontsize=10, fontcolor="#708090"];
  }
}
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/docs/data-flow.dot
<DOCUMENT>
digraph BlogSite_DataFlow {
  rankdir=LR;
  graph [bgcolor="#F5F7FA", splines=spline, pad=0.5, nodesep=1.0, ranksep=1.5];
  node [shape=box, style="filled,rounded", fillcolor="#FFFFE0", color="#DAA520", penwidth=2, fontname="Arial", fontsize=12, margin=0.2];
  edge [color="#2F4F4F", fontname="Arial", fontsize=11, arrowsize=0.8, penwidth=1.5, splines=spline];

  // Title
  labelloc="t";
  label="BlogSite API Data Flow";
  fontsize=16;
  fontname="Arial";
  fontcolor="#2F4F4F";

  // Components
  Frontend [label="Frontend\nSends HTTP Requests\nReceives JSON Responses", fillcolor="#FFFACD"];
  Middleware [label="Middleware\n- Validation (Joi)\n- Authentication (JWT)", fillcolor="#FFFFE0"];
  API_Routes [label="API Routes\nHandles /api/users\n/api/posts, /api/comments", fillcolor="#FFFACD"];
  Controllers [label="Controllers\nProcesses Logic\n- createPost\n- getComments\n- registerUser", fillcolor="#FFFFE0"];
  Models [label="Mongoose Models\nUser, Post, Comment\nHandles DB Operations", fillcolor="#FFFACD"];
  MongoDB [label="MongoDB\nStores & Retrieves Data\nUses Indexes", fillcolor="#FFFFE0"];

  // Data Flow
  Frontend -> Middleware [label="HTTP Request\n(e.g., POST /api/posts)", style=solid, color="#2F4F4F", arrowhead=vee];
  Middleware -> API_Routes [label="Validated Request", style=solid, color="#4682B4", penwidth=2.5, arrowhead=vee];
  API_Routes -> Controllers [label="Route Mapping\n(e.g., /api/posts → createPost)", style=solid, color="#2F4F4F", arrowhead=vee];
  Controllers -> Models [label="Business Logic\n- Validation/Sanitization\n- Pagination/Filtering\n- Update Related Docs", style=solid, color="#4682B4", penwidth=2.5, arrowhead=vee];
  Models -> MongoDB [label="MongoDB Query\n(e.g., save, find, populate)", style=solid, color="#2F4F4F", arrowhead=vee];
  MongoDB -> Models [label="Query Result", style=solid, color="#2F4F4F", arrowhead=vee];
  Models -> Controllers [label="Processed Data", style=solid, color="#2F4F4F", arrowhead=vee];
  Controllers -> API_Routes [label="Response Data", style=solid, color="#2F4F4F", arrowhead=vee];
  API_Routes -> Middleware [label="JSON Response", style=solid, color="#2F4F4F", arrowhead=vee];
  Middleware -> Frontend [label="HTTP Response\n+ JWT Cookie (auth)", style=solid, color="#4682B4", penwidth=2.5, arrowhead=vee];

  // Legend
  subgraph cluster_legend {
    label="Legend";
    fontsize=12;
    fontname="Arial";
    style="dashed,rounded";
    color="#708090";
    fillcolor="#F0F8FF";
    Legend [shape=plaintext, label="Solid Line: Data Flow\nBlue/Thick Line: Critical Flow\nMiddleware: Validation & Auth\nJWT Cookie: Auth Token"];
  }

  // Footer Note
  subgraph cluster_footer {
    style=invis;
    Footer [shape=plaintext, label="Generated for BlogSite Backend, Task 3, July 2025", fontsize=10, fontcolor="#708090"];
  }
}
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/docs/query-performance.md
<DOCUMENT>
# Query Performance Guide

## Indexing Strategy

- **User Model** :
- `username`: Unique index for fast lookup and uniqueness enforcement.
- `email`: Unique index for fast lookup and uniqueness enforcement.
- **Post Model** :
- `author`: Index for efficient population and filtering by author.
- `createdAt`: Index for sorting posts by creation date.
- `tags`: Index for filtering posts by tags.
- **Comment Model** :
- `post`: Index for retrieving comments by post ID.
- `createdAt`: Index for sorting comments by creation date.

## Optimization Techniques

- **Pagination** : Uses `mongoose-paginate-v2` to limit results (default 10 per page).
- **Population** : Efficiently fetches referenced User and Comment data in queries.
- **Query Caching** : Leverages MongoDB’s built-in query caching for frequently accessed data.
- **Selective Fields** : Only necessary fields are returned in queries to reduce data transfer.
- **Compound Indexes** : Considered for frequent query patterns (e.g., post filtering by tag and date).

## Performance Considerations

- Indexes reduce query execution time for large datasets.
- Population is used judiciously to avoid excessive joins.
- Pagination prevents overloading the server with large result sets.
- Validation occurs at the schema level to minimize runtime errors.
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/docs/erd.dot
<DOCUMENT>
digraph BlogSite_ERD {
  rankdir=LR;
  graph [bgcolor="#F5F7FA", splines=spline, pad=0.5, nodesep=0.8, ranksep=1.2];
  node [shape=box, style="filled,rounded", fillcolor="#ADD8E6", color="#4682B4", penwidth=2, fontname="Arial", fontsize=12, margin=0.2];
  edge [color="#2F4F4F", fontname="Arial", fontsize=11, arrowsize=0.8, penwidth=1.5, splines=spline];

  // Title
  labelloc="t";
  label="BlogSite Entity-Relationship Diagram";
  fontsize=16;
  fontname="Arial";
  fontcolor="#2F4F4F";

  // Entities
  User [label="User\n_id: ObjectId (PK, bold)\nusername: String (unique, req)\nemail: String (unique, req)\npassword: String (req)\ncreatedAt: Date\nupdatedAt: Date\nposts: Virtual (ref: Post, dashed)", fillcolor="#B3E5FC"];
  Post [label="Post\n_id: ObjectId (PK, bold)\ntitle: String (req)\ncontent: String (req)\nauthor: ObjectId (ref: User, req)\ntags: [String]\ncomments: [ObjectId (ref: Comment)]\ncreatedAt: Date\nupdatedAt: Date", fillcolor="#ADD8E6"];
  Comment [label="Comment\n_id: ObjectId (PK, bold)\ncontent: String (req)\nauthor: ObjectId (ref: User, req)\npost: ObjectId (ref: Post, req)\ncreatedAt: Date\nupdatedAt: Date", fillcolor="#B3E5FC"];

  // Relationships
  User -> Post [label="1:N (author)", style=solid, color="#4682B4", arrowhead=vee];
  Post -> Comment [label="1:N (comments)", style=solid, color="#4682B4", arrowhead=vee];
  User -> Comment [label="1:N (author)", style=solid, color="#4682B4", arrowhead=vee];
  Post -> Tags [label="N:N (tags)", style=dotted, color="#2F4F4F", arrowhead=vee];

  // Legend
  subgraph cluster_legend {
    label="Legend";
    fontsize=12;
    fontname="Arial";
    style="dashed,rounded";
    color="#708090";
    fillcolor="#F0F8FF";
    Legend [shape=plaintext, label="Solid Line: One-to-Many\nDotted Line: Many-to-Many\nBold: Primary Key\nDashed: Virtual Field"];
  }

  // Footer Note
  subgraph cluster_footer {
    style=invis;
    Footer [shape=plaintext, label="Generated for BlogSite Backend, Task 3, July 2025", fontsize=10, fontcolor="#708090"];
  }
}
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/docs/data-flow.md
<DOCUMENT>
# Data Flow Documentation

## Overview

This document describes how data moves through the BlogSite application for major operations, focusing on the interactions between frontend requests, backend routes, controllers, and MongoDB.

## Create Post

1. **Request** : Frontend sends POST `/api/posts` with title, content, tags, and author ID.
2. **Validation** : Middleware validates the request body using Joi schema.
3. **Controller** : `createPost` creates a new Post document and saves it to MongoDB.
4. **Response** : Returns the created post with populated author data.

## Get Posts

1. **Request** : Frontend sends GET `/api/posts?page=1&limit=10&sort=createdAt&order=desc&tag=tech`.
2. **Controller** : `getPosts` processes query parameters, applies pagination, filtering, and sorting.
3. **Database** : MongoDB query with `mongoose-paginate-v2` fetches posts with populated author data.
4. **Response** : Returns paginated posts with metadata (total pages, count).

## Create Comment

1. **Request** : Frontend sends POST `/api/comments` with content, author ID, and post ID.
2. **Validation** : Middleware validates the request body.
3. **Controller** : `createComment` creates a Comment document and updates the Post’s comments array.
4. **Response** : Returns the created comment.

## Get Comments

1. **Request** : Frontend sends GET `/api/comments/post/:postId?page=1&limit=10`.
2. **Controller** : `getComments` fetches comments for the specified post with pagination and populated author data.
3. **Response** : Returns paginated comments with metadata.

## Data Flow Diagram

- **Frontend → API** : HTTP requests to `/api` endpoints.
- **API → Controller** : Routes map to controller functions.
- **Controller → Model** : Mongoose models handle database operations.
- **Model → MongoDB** : Executes queries with indexing and population.
- **MongoDB → Response** : Returns data through controllers to the frontend.
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/docs/database-design.md
<DOCUMENT>
# Database Design Document

## Overview

This document outlines the MongoDB schema design for the BlogSite application, focusing on users, posts, and comments with one-to-many and many-to-many relationships, optimized for performance.

## Schema Rationale

- **User** : Stores unique username and email with indexes for fast lookup. Virtual field for posts enables efficient population.
- **Post** : References the author (User) for one-to-many relationship and embeds comment IDs for one-to-many with comments. Tags array supports many-to-many filtering. Indexes on author, createdAt, and tags optimize queries.
- **Comment** : References both author (User) and post (Post) for one-to-many relationships. Indexes on post and createdAt improve query performance.

## Relationships

- **One-to-Many** : User to Posts (one user can have many posts)
- **One-to-Many** : Post to Comments (one post can have many comments)
- **Many-to-Many** : Posts to Tags (via tags array, searchable)

## Indexing Strategy

- **User** : Indexes on `username` and `email` for unique constraints and fast lookups.
- **Post** : Indexes on `author` (for user-post queries), `createdAt` (for sorting), and `tags` (for filtering).
- **Comment** : Indexes on `post` and `createdAt` for efficient retrieval of comments by post.

## Optimization Techniques

- **Population** : Used for referencing User and Comment data, reducing data duplication.
- **Pagination** : Implemented using mongoose-paginate-v2 to limit result sets.
- **Query Planning** : Indexes ensure efficient filtering and sorting operations.
- **Schema Validation** : Mongoose schemas enforce data integrity with required fields and constraints.

## Data Flow

1. **User Creation** : Users are created with unique username and email.
2. **Post Creation** : Posts reference an author and can include tags. Comments are linked via IDs.
3. **Comment Creation** : Comments reference both a post and an author, updating the post’s comments array.
4. **Retrieval** : GET requests use pagination, populate references, and support sorting/filtering.
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/controllers/post.controller.js
<DOCUMENT>
import Post from '../models/post.model.js';
import Comment from '../models/comment.model.js';
import { asyncHandler } from '../utils/helpers.js';

export const createPost = asyncHandler(async (req, res) => {
  const { title, content, tags } = req.body;
  const post = new Post({ title, content, tags, author: req.user.id });
  await post.save();
  res.status(201).json({ message: 'Post created successfully', post });
});

export const getPosts = asyncHandler(async (req, res) => {
  const {
    page = 1,
    limit = 10,
    sort = 'createdAt',
    order = 'desc',
    tag,
  } = req.query;
  const query = tag ? { tags: tag } : {};
  const options = {
    page: parseInt(page, 10),
    limit: parseInt(limit, 10),
    sort: { [sort]: order === 'desc' ? -1 : 1 },
    populate: { path: 'author', select: '-password' },
  };
  const posts = await Post.paginate(query, options);
  res.json(posts);
});

export const getPost = asyncHandler(async (req, res) => {
  const post = await Post.findById(req.params.id)
    .populate('author', 'username email')
    .populate({
      path: 'comments',
      populate: { path: 'author', select: 'username email' },
    });
  if (!post) {
    return res.status(404).json({ message: 'Post not found' });
  }
  res.json(post);
});

export const updatePost = asyncHandler(async (req, res) => {
  const { title, content, tags } = req.body;
  const post = await Post.findOne({ _id: req.params.id, author: req.user.id });
  if (!post) {
    return res.status(404).json({ message: 'Post not found or unauthorized' });
  }
  post.title = title || post.title;
  post.content = content || post.content;
  post.tags = tags || post.tags;
  post.updatedAt = Date.now();
  await post.save();
  res.json({ message: 'Post updated successfully', post });
});

export const deletePost = asyncHandler(async (req, res) => {
  const post = await Post.findOne({ _id: req.params.id, author: req.user.id });
  if (!post) {
    return res.status(404).json({ message: 'Post not found or unauthorized' });
  }
  await Post.deleteOne({ _id: req.params.id });
  await Comment.deleteMany({ post: req.params.id });
  res.json({ message: 'Post deleted successfully' });
});
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/controllers/comment.controller.js
<DOCUMENT>
import Comment from '../models/comment.model.js';
import Post from '../models/post.model.js';
import { asyncHandler } from '../utils/helpers.js';

export const createComment = asyncHandler(async (req, res) => {
  const { content, post } = req.body;
  const comment = new Comment({ content, author: req.user.id, post });
  await comment.save();
  await Post.findByIdAndUpdate(post, { $push: { comments: comment._id } });
  res.status(201).json({ message: 'Comment created successfully', comment });
});

export const getComments = asyncHandler(async (req, res) => {
  const {
    page = 1,
    limit = 10,
    sort = 'createdAt',
    order = 'desc',
  } = req.query;
  const options = {
    page: parseInt(page, 10),
    limit: parseInt(limit, 10),
    sort: { [sort]: order === 'desc' ? -1 : 1 },
    populate: { path: 'author', select: 'username email' },
  };
  const comments = await Comment.paginate({ post: req.params.postId }, options);
  res.json(comments);
});

export const updateComment = asyncHandler(async (req, res) => {
  const { content } = req.body;
  const comment = await Comment.findOne({
    _id: req.params.id,
    author: req.user.id,
  });
  if (!comment) {
    return res
      .status(404)
      .json({ message: 'Comment not found or unauthorized' });
  }
  comment.content = content || comment.content;
  comment.updatedAt = Date.now();
  await comment.save();
  res.json({ message: 'Comment updated successfully', comment });
});

export const deleteComment = asyncHandler(async (req, res) => {
  const comment = await Comment.findOne({
    _id: req.params.id,
    author: req.user.id,
  });
  if (!comment) {
    return res
      .status(404)
      .json({ message: 'Comment not found or unauthorized' });
  }
  await Comment.deleteOne({ _id: req.params.id });
  await Post.findByIdAndUpdate(comment.post, {
    $pull: { comments: comment._id },
  });
  res.json({ message: 'Comment deleted successfully' });
});
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/controllers/user.controller.js
<DOCUMENT>
import jwt from 'jsonwebtoken';
import User from '../models/user.model.js';
import { asyncHandler } from '../utils/helpers.js';

export const registerUser = asyncHandler(async (req, res) => {
  const { username, email, password } = req.body;
  const user = new User({ username, email, password });
  await user.save();

  const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, {
    expiresIn: '7d',
  });

  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  res.status(201).json({
    message: 'User registered successfully',
    user: { id: user._id, username, email },
  });
});

export const loginUser = asyncHandler(async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });
  if (!user || !(await user.comparePassword(password))) {
    return res.status(401).json({ message: 'Invalid credentials' });
  }

  const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, {
    expiresIn: '7d',
  });

  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  res.json({
    message: 'Login successful',
    user: { id: user._id, username: user.username, email },
  });
});

export const logoutUser = asyncHandler(async (req, res) => {
  res.clearCookie('token');
  res.json({ message: 'Logout successful' });
});

export const getUser = asyncHandler(async (req, res) => {
  const user = await User.findById(req.params.id)
    .select('-password')
    .populate('posts');
  if (!user) {
    return res.status(404).json({ message: 'User not found' });
  }
  res.json(user);
});

export const getCurrentUser = asyncHandler(async (req, res) => {
  const user = await User.findById(req.user.id)
    .select('-password')
    .populate('posts');
  if (!user) {
    return res.status(404).json({ message: 'User not found' });
  }
  res.json(user);
});
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/routes/post.routes.js
<DOCUMENT>
import express from 'express';
import {
  createPost,
  getPosts,
  getPost,
  updatePost,
  deletePost,
} from '../controllers/post.controller.js';
import { validate } from '../middlewares/validate.middleware.js';
import { createPostSchema, updatePostSchema } from '../utils/helpers.js';
import { authMiddleware } from '../middlewares/auth.middleware.js';

const router = express.Router();

router.post('/', authMiddleware, validate(createPostSchema), createPost);
router.get('/', getPosts);
router.get('/:id', getPost);
router.put('/:id', authMiddleware, validate(updatePostSchema), updatePost);
router.delete('/:id', authMiddleware, deletePost);

export default router;
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/routes/comment.routes.js
<DOCUMENT>
import express from 'express';
import {
  createComment,
  getComments,
  updateComment,
  deleteComment,
} from '../controllers/comment.controller.js';
import { validate } from '../middlewares/validate.middleware.js';
import { createCommentSchema, updateCommentSchema } from '../utils/helpers.js';
import { authMiddleware } from '../middlewares/auth.middleware.js';

const router = express.Router();

router.post('/', authMiddleware, validate(createCommentSchema), createComment);
router.get('/post/:postId', getComments);
router.put(
  '/:id',
  authMiddleware,
  validate(updateCommentSchema),
  updateComment
);
router.delete('/:id', authMiddleware, deleteComment);

export default router;
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/routes/index.js
<DOCUMENT>
import express from 'express';
import userRoutes from './user.routes.js';
import postRoutes from './post.routes.js';
import commentRoutes from './comment.routes.js';

const router = express.Router();

router.get('/', (req, res) => res.json({ message: 'API is up and running!' }));
router.use('/users', userRoutes);
router.use('/posts', postRoutes);
router.use('/comments', commentRoutes);

export default router;
</DOCUMENT>

/Users/macbook/Documents/BlogSite/server/src/routes/user.routes.js
<DOCUMENT>
import express from 'express';
import {
  registerUser,
  loginUser,
  logoutUser,
  getUser,
  getCurrentUser,
} from '../controllers/user.controller.js';
import { validate } from '../middlewares/validate.middleware.js';
import { registerUserSchema, loginUserSchema } from '../utils/helpers.js';
import { authMiddleware } from '../middlewares/auth.middleware.js';

const router = express.Router();

router.post('/register', validate(registerUserSchema), registerUser);
router.post('/login', validate(loginUserSchema), loginUser);
router.post('/logout', logoutUser);
router.get('/me', authMiddleware, getCurrentUser);
router.get('/:id', getUser);

export default router;
</DOCUMENT>

